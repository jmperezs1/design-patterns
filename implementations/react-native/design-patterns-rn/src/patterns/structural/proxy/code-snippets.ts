import type { CodeSnippet } from '../../../registry/types';

export const proxyCodeSnippets: CodeSnippet[] = [
  { title: 'subject.ts', language: 'ts', code: `import type { Product } from './type/type';\n\nexport interface ProductService {\n  getProduct(id: string): Promise<Product>;\n}` },
  { title: 'real-subject.ts', language: 'ts', code: `import type { ProductService } from './subject';\nimport type { Product } from './type/type';\n\nexport class HttpProductService implements ProductService {\n  private hits = 0;\n  async getProduct(id: string): Promise<Product> {\n    this.hits++;\n    await sleep(600);\n    return { id, name: \`Product ${'${'}id}\`, price: 10 + Number(id) * 1.5 };\n  }\n  getNetworkHits() { return this.hits; }\n}\nconst sleep = (ms: number) => new Promise(res => setTimeout(res, ms));` },
  { title: 'proxy.ts', language: 'ts', code: `import { HttpProductService } from './real-subject';\nimport type { ProductService } from './subject';\nimport type { Product } from './type/type';\n\nexport class CachingProductProxy implements ProductService {\n  private real: HttpProductService;\n  private cache = new Map<string, Product>();\n  private inflight = new Map<string, Promise<Product>>();\n  private hits = 0;\n  private misses = 0;\n  constructor(real = new HttpProductService()) { this.real = real; }\n  async getProduct(id: string): Promise<Product> {\n    const cached = this.cache.get(id); if (cached) { this.hits++; return cached; }\n    const pending = this.inflight.get(id); if (pending) { this.hits++; return pending; }\n    this.misses++;\n    const req = this.real.getProduct(id).then(p => { this.cache.set(id, p); this.inflight.delete(id); return p; }).catch(err => { this.inflight.delete(id); throw err; });\n    this.inflight.set(id, req);\n    return req;\n  }\n  getStats() { return { cacheHits: this.hits, cacheMisses: this.misses, networkCalls: this.real.getNetworkHits(), cacheSize: this.cache.size, inflight: this.inflight.size }; }\n  clearCache() { this.cache.clear(); }\n}` },
];
